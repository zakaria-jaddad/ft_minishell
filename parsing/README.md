<!--toc:start-->

- [Parts of a shell Program](#parts-of-a-shell-program)
  - [The Parser](#the-parser)
  - [The Executor](#the-executor)
- [Shell Subsystems](#shell-subsystems)
- [Using Lex and Yacc to implement the Parser](#using-lex-and-yacc-to-implement-the-parser)
- [Representing Code aka (Given Line)](#representing-code-aka-given-line)
  - [Generating the Abstract syntax tree](#generating-the-abstract-syntax-tree)
- [Expanding Wildcards **\***](#expanding-wildcards)
<!--toc:end-->

## Parts of a shell Program

The shell implementation is divided into three parts:

- **The Parser**
- **The Executor**
### The Parser

The parser is the software component that reads the command line, and puts it into a data structure
**Command Table** that will store the commands that will be executed.

### The Executor

The executor will take the command table generated by the parser, and for every command, it will create a new process.

It will also if necessary create pipes for communication between process.

It will redirect the standard input, output and error is there are any redirections.

Type of redirections:

- `>`: redirect the output of the command to an _outfile_

```bash
    ls -la > outfile
```

- `<`: input of the first command is redirected from the _infile_

```bash
    cat < infile
```

Example of a sequence of commands with redirections

```bash
cat | wc -l > tmp < hello
```

Shell redirect the content of _hello_ file as an input to the `cat` command.

`wc -l` uses the output of `cat` as an input, then output will be redirected to the tmp file

- if **tmp** exist:
  -> It's content will be overwritten
- if **tmp** does not exist:
  -> tmp file would be created, with the redirected content

## Shell Subsystems

There are other subsystems that complete the shell which are:

- **Environment Variables**: The shell should be able to _set_, _expand_ and _print_ environment variables
  of the form `$VAR` or `${VAR}`

- **Wildcards**: The wildcards of the form `*` or `a*a` should be expanded to all the files that match them in the local directory
  and multiple directories.

- **Subshells**: Not required but why not!!, `command` or `$(command)`
  commands are executed in a subshell, it's output is sent as input to the shell.

## Using Lex and Yacc to implement the Parser

we will use two UNIX tools to implement a parser: **Flex** and **Yacc**. These tools are used to
implement _compilers_, _interpreters_, and _preprocessors_.

Lexer: _Lexical analysis_, _tockenization_ is the process of converting a sequence of _characters_ into a meaningful sequence of lexical tokens

Yacc: yet another compiler compiler is a parser generator for compilers

`cmd [arg]*`: each command can be represented as a _command_name + argument_

- command name **cmd**
- 0 or more argument for the command

A simple pipe contains 2 or more commands:

`cmd [arg]* [ | cmd [arg]* ]*`

- a command with 0 or more arguments
- a pipe `|`
- othre command with 0 or more argument

a command can have one or more input, output redirections

`[[[> filename] [>> filename]] [< filename]]*`

if there are one or more filenames, last file in the list will be used, since files overwrite each other

if one of the files don't have permissions, file i/o stops.

## Representing Code aka (Given Line)

In The process of Parsing, We took the raw line and transformed it into a slightly higher-level representation: a series of tokens,
then takes these tokens and transforms them yet again, into an even richer complex representation.

NOTE: The main goal: the representation should be sipmle for the parser to produce and easy for the interpreter to consume.

For example when evaluating `1 + 2 * 3 - 4`, we know that the multiplication is evaluated before the addition of subtraction,
one way to visulaize that prcedence is using a tree Leaf nodes are numbers, and interior nodes are operators with branches for each of their operands.

In order to evalure an arithmetic node, you need to know the numeric valuesof its subtrees, so you have to evaluate those first.
That means working your way from the leaves up to the root, in a _post-order_ traversal:

![post-order traversal](./media/tree-evaluate.png)

A. Starting with the full tree, evaluate the bottom-most operation, `2 * 3`.

B. Now we can evaluate the `+`.

C. Next, the `-`.

D. The final answer.

### Generating the Abstract syntax tree

When dealing with trees, specifically when debugging, we need to print the tree, that's called **pretty printin**

When the goal is to produce a string of text that is valid syntax in the source language.

We want the string to very explicitly show the nesting structure of the tree, Code that print `1 * 2 * 3` isn't helpful.

For example:

```bash
ls -a && (echo "hello world" || cat filename)
```

Pretty printer produces:

Visulaizer, it's creating is a mandatory to check weather your parsing ast is correct.

```
(&& (ls -a) (group (echo "hello world") (cat filename)))
```

#### get_root function

get_root function is the key for an easy and structure parsing.

The purpos of the function is at each call to it returns a pointer to the root of the given command, for example: 

```bash

(ls | cat) && echo hello world
           ^^
           ||
```

get root function return a pointer to the height priority node in the tokens list

## Pre AST

When working on converting tokens to a mini AST, i have faced multiple challenges one of them is how redirections implemented.

Redirection components are: `command redirection filename`, which is the well known and used redirection structure in bash: 

```bash
ls -a > out
```

But in bash there are multiple ways of writing redirections

```bash
> out ls -a
> out > otherout ls -a # in this case out and otherout are created but ls -a output will be redirected to otherout
```

Or heck even this is a valid syntax in bash
```bash
> out # create out
```

So i comme up with an idea on a _pre ast_

The main purpos of pre_ast was the need of effectively order redirections

When the provided command is : `> filename command arguments`

The `pre_ast` function should enhance the generated tokens for batter ast generating

`pre_ast` output `command arguments > filename`

When finding a re-directions:

No need to peak and check prev token.

skip all current redirs, than get commands or arguments

Than cut and past them before the first occurrence of the first redirection

peaking either next or prev is a method to check the next or prev token either getting it's type or it's data

```rust
void pre_ast(t_list **tokens)
{
        t_list *current_token;
        int i = 0;

        if (tokens == NULL)
                return ;
        current_token = *tokens;
        while (current_token)
        {
                // check if the current tokens is a redirection
                if (is_redirection(current_token->content)) 
                {
                        // skip all redirections and cut all words, then put them before first redirection occurrence
                        enhance_redirections(&current_token, tokens);
                        continue ;
                }
                current_token = current_token->next;
        }
}
```

